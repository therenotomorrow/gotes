package main

import (
	"cmp"
	"fmt"
	"strings"

	"github.com/therenotomorrow/ex"
	"github.com/therenotomorrow/gotes/plugin/verbose/v1/options"
	"google.golang.org/protobuf/compiler/protogen"
	"google.golang.org/protobuf/proto"
)

func main() {
	New().Run()
}

const (
	defaultSuffix = "verbose"
	optionSuffix  = "suffix"

	ErrUnknownOption ex.Error = "unknown option"
)

type config struct {
	suffix string
}

type Generator struct {
	config *config
}

func New() *Generator {
	return &Generator{config: &config{
		suffix: defaultSuffix,
	}}
}

func (vg *Generator) Run() {
	opts := protogen.Options{
		ParamFunc: func(name string, value string) error {
			if name == optionSuffix {
				vg.config.suffix = cmp.Or(value, vg.config.suffix)

				return nil
			}

			return ErrUnknownOption.Reason("unknown option '" + name + "'")
		},
		ImportRewriteFunc:            nil,
		InternalStripForEditionsDiff: nil,
		DefaultAPILevel:              0,
	}

	opts.Run(func(plugin *protogen.Plugin) error {
		for _, file := range plugin.Files {
			if !file.Generate {
				continue
			}

			vg.generateFile(plugin, file)
		}

		return nil
	})
}

func (vg *Generator) generateFile(plugin *protogen.Plugin, file *protogen.File) {
	if len(file.Messages) == 0 {
		return // do not generate for services or enums only
	}

	filename := fmt.Sprintf("%s.pb.%s.go", file.GeneratedFilenamePrefix, vg.config.suffix)
	gen := plugin.NewGeneratedFile(filename, file.GoImportPath)

	gen.P("// Code generated by protoc-gen-verbose. DO NOT EDIT.")
	gen.P("// source: ", file.Desc.Path())
	gen.P()
	gen.P("package ", file.GoPackageName)
	gen.P()

	for _, message := range file.Messages {
		vg.generateVerbose(gen, message)
	}
}

func (vg *Generator) generateVerbose(gen *protogen.GeneratedFile, message *protogen.Message) {
	fmtSprintf := gen.QualifiedGoIdent(protogen.GoIdent{
		GoName:       "Sprintf",
		GoImportPath: "fmt",
	})

	gen.P("func (x *", message.GoIdent, ") Verbose() string {")
	gen.P("if x == nil {")
	gen.P(`	return "<nil>"`)
	gen.P("}")

	fmts := make([]string, 0)
	args := make([]string, 0)

	for _, field := range message.Fields {
		if field.Oneof != nil {
			continue // process it later
		}

		if vg.isNoFormat(field) {
			continue
		}

		fmts = append(fmts, field.GoName+"=%v")
		args = append(args, "x."+field.GoName)
	}

	for _, oneOf := range message.Oneofs {
		valVar := "oneOfVal_" + oneOf.GoName
		gen.P(valVar, ` := "<nil>"`)

		gen.P("switch v := x.Get", oneOf.GoName, "().(type) {")

		for _, field := range oneOf.Fields {
			if vg.isNoFormat(field) {
				continue
			}

			gen.P("case *", field.GoIdent, ":")
			gen.P(valVar, " = ", fmtSprintf, `("%v", v.`, field.GoName, ")")
		}

		gen.P("}")

		fmts = append(fmts, fmt.Sprintf("%s=%%s", oneOf.GoName))
		args = append(args, valVar)
	}

	formatStr := fmt.Sprintf("%s<%s>", message.GoIdent.GoName, strings.Join(fmts, ", "))

	if len(args) > 0 {
		gen.P("return ", fmtSprintf, "(", fmt.Sprintf("%q", formatStr), ", ", strings.Join(args, ", "), ")")
	} else {
		gen.P("return ", fmtSprintf, "(", fmt.Sprintf("%q", formatStr), ")")
	}

	gen.P("}")
	gen.P()

	for _, nested := range message.Messages {
		vg.generateVerbose(gen, nested)
	}
}

func (vg *Generator) isNoFormat(field *protogen.Field) bool {
	opts := field.Desc.Options()

	if proto.HasExtension(opts, options.E_Noformat) {
		val, ok := proto.GetExtension(opts, options.E_Noformat).(bool)
		if ok {
			return val
		}
	}

	return false
}
